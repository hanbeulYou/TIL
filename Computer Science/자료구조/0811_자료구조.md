# 자료구조

## 복잡도

### 1. 시간복잡도

시간복잡도란 ‘문제를 해결하는데 걸리는 시간과 입력의 함수 관계’

- 점근표기법 : 입력 범위 n을 기준으로 로직이 몇 번 반복되는지 나타내는 것
    - 빅-오 표기법(Big-O notation) : 점근적 상한선
    - 빅-오메가 표기법(Big-Omega(Ω) notation) : 점근적 하한선
    - 빅-세타 표기법(Big-Theta(Θ) notation) : 점근적 상한과 하한의 교집합
    - 이외에 스몰-오 표기법 및 스몰-오메가 표기법 등이 존재한다.
    - 가장 주로 사용되는 것은 빅-오 표기법으로 최악의 상황을 가정하여 알고리즘의 시간 복잡도를 평가
- 시간 복잡도의 존재 이유
    - 효율적인 코드로 개선하는데 쓰이는 척도
- 시간 복잡도의 속도 비교
    - O(1) < O(logN) < O(N) < O(NlogN) < O(N^2) < O(N^3) < O(2^N) < O(N!)

---

### 2. 공간복잡도

프로그램을 실행시켰을 때 필요로 하는 자원 공간의 양

(동적으로 할당되는 공간에 대해서도 생각해줘야함)

- C언어의 자료형과 각 자료형이 차지하는 메모리 크기
    - byte : 1byte (8bits)
    - char : 1byte (8bits)
    - short : 2byte
    - int : 4byte
    - long : 4byte
    - long long : 8byte
    - float : 4byte
    - double : 8byte
    - long double : 8byte 이상
- Python
    - 파이썬의 메모리는 C언어와 다름
    - 변수가 직접 메모리를 할당 받는 것이 아니고 클라스가 객체를 가리키는 형식
    - int의 경우 28byte나 차지한다고 한다(동적으로 변화 가능)
    - 기타 자세한 사항은 메모리 관련 공부할 때 자세히 다뤄보자

---

### 3. 자료 구조에서의 시간 복잡도

평균 시간 복잡도와 최악의 시간 복잡도를 고려하여 자료 구조 사용

- 자료 구조의 평균 시간 복잡도

| 자료 구조 | 접근 | 탐색 | 삽입 | 삭제 |
| --- | --- | --- | --- | --- |
| 배열(array) | O(1) | O(n) | O(n) | O(n) |
| 스택(stack) | O(n) | O(n) | O(1) | O(1) |
| 큐(queue) | O(n) | O(n) | O(1) | O(1) |
| 이중 연결 리스트(doubly linked list) | O(n) | O(n) | O(1) | O(1) |
| 해시 테이블(hash table) | O(1) | O(1) | O(1) | O(1) |
| 이진 탐색 트리(BST) | O(logn) | O(logn) | O(logn) | O(logn) |
| AVL 트리 | O(logn) | O(logn) | O(logn) | O(logn) |
| 레드 블랙 트리 | O(logn) | O(logn) | O(logn) | O(logn) |
- 최악의 시간 복잡도

| 자료 구조 | 접근 | 탐색 | 삽입 | 삭제 |
| --- | --- | --- | --- | --- |
| 배열(array) | O(1) | O(n) | O(n) | O(n) |
| 스택(stack) | O(n) | O(n) | O(1) | O(1) |
| 큐(queue) | O(n) | O(n) | O(1) | O(1) |
| 이중 연결 리스트(doubly linked list) | O(n) | O(n) | O(1) | O(1) |
| 해시 테이블(hash table) | O(n) | O(n) | O(n) | O(n) |
| 이진 탐색 트리(BST) | O(n) | O(n) | O(n) | O(n) |
| AVL 트리 | O(logn) | O(logn) | O(logn) | O(logn) |
| 레드 블랙 트리 | O(logn) | O(logn) | O(logn) | O(logn) |

## 선형 자료 구조

요소가 일렬로 나열되어 있는 자료구조

### 1. 연결리스트(Linked List)

데이터를 감싼 노드를 포인터로 연결해서 공간적인 효율성을 극대화시킨 자료 구조

![https://www.alphacodingskills.com/imgfiles/doubly-linked-list.PNG](https://www.alphacodingskills.com/imgfiles/doubly-linked-list.PNG)

prev 포인터로 앞의 node의 주소를 가르키고, next 포인터로 다음 node의 주소를 가리킴

맨 앞에 있는 node를 head라고 부름

- 싱글 연결 리스트 : next 포인터만 가짐
- 이중 연결 리스트 : next 포인터와 prev 포인터를 가짐
- 원형 이중 연결 리스트 : 이중 연결 리스트와 같지만 마지막 node의 next 포인터가 head의 주소를 가리킴

---

### 2. 배열(Array)

같은 타입의 변수들로 이루어져 있고, 크기가 정해져 있으며, 인접한 메모리 위치에 있는 데이터를 모아놓은 집합. 중복을 허용하고 순서가 있음.

- 랜덤 접근과 순차적 접근이 가능
    - 랜덤 접근 : index를 활용한 임의의 접근 가능
    - 순차적 접근 : 저장된 순서대로 검색해야 함
- 연결 리스트와의 차이
    - 탐색은 배열이 빠르고 연결 리스트가 느림
    - 데이터 추가 및 삭제는 연결 리스트가 빠르고 배열이 느림

---

### 3. 벡터(Vector)

동적으로 요소를 할당할 수 있는 동적 배열. 중복을 허용하고 랜덤 접근 가능.

- 뒤부터 요소를 더하는 push_back() : 벡터의 크기가 (2의 제곱승 + 1)이 될 때마다 크기를 2배로 늘림(O(1), amortized 복잡도)
    - push_back()의 amortized 복잡도에 관한 링크 : [https://codingdog.tistory.com/entry/amortized-복잡도-average-complexity와-뭐가-다른가요](https://codingdog.tistory.com/entry/amortized-%EB%B3%B5%EC%9E%A1%EB%8F%84-average-complexity%EC%99%80-%EB%AD%90%EA%B0%80-%EB%8B%A4%EB%A5%B8%EA%B0%80%EC%9A%94)
- push_back(), pop_back(), erase(), find(), clear() 함수가 있음(C++ 기준)

---

### 4. 스택(Stack)

가장 마지막으로 들어간 데이터가 가장 첫 번째로 나오는 성질(LIFO, Last In First Out)을 가진 자료 구조.

![https://wayhome25.github.io/assets/post-img/cs/stack.jpg](https://wayhome25.github.io/assets/post-img/cs/stack.jpg)

- 재귀적인 함수 및 알고리즘, 웹 브라우저 방문 기록 등에 사용됨.

---

### 5. 큐(Queue)

먼저 넣은 데이터가 먼저 나오는 성질(FIFO, First In First Out)을 가진 자료 구조

![https://wayhome25.github.io/assets/post-img/cs/queue1.jpg](https://wayhome25.github.io/assets/post-img/cs/queue1.jpg)

![https://wayhome25.github.io/assets/post-img/cs/queue2.jpg](https://wayhome25.github.io/assets/post-img/cs/queue2.jpg)

- CPU 작업을 기다리는 프로세스, 스레드 행렬 또는 네트워크 접속을 기다리는 행렬, 너비 우선 탐색(BFS), 캐시 등에 사용됨.

---

## 비선형 자료 구조

자료의 구조가 일렬로 나열되지 않고 자료 순서나 관계가 복잡한 구조

### 1. 그래프(Graph)

정점(vertex)와 간선(edge)로 이루어진 자료 구조

- 정점과 간선
    - 정점 : 여러가지 특성을 가질 수 있는 객체
    - 간선 : 정점들간의 관계
    - 단방향/양방향 간선 : 간선에는 방향성이 있음
    - outdegree : 다른 정점으로 나가는 간선
    - indegree : 다른 정점으로부터 들어오는 간선
- 가중치 : 간선과 정점 사이에 드는 비용

---

### 2. 트리(Tree)

그래프 중 하나. 정점과 간선으로 이루어져 있고, 트리 구조로 배열된 일종의 계층적 데이터의 집합.

루트 노드, 내부 노드, 리프 노드 등으로 구성 됨.

트리로 이루어진 집합을 숲이라 함.

- 트리의 특징
    - 부모, 자식 계층 구조를 가짐
    - 간선 수 = 노드 수 - 1
    - 임의의 두 노드 사이의 경로는 ‘유일무이'하게 ‘존재'함
- 트리의 구성
    - 루트 노드 : 가장 위에 있는 노드
    - 내부 노드 : 루트 노드와 리프 노드 사이에 있는 노드
    - 리프 노드 : 자식 노드가 없는 노드
- 트리의 높이와 레벨
    - 깊이 : 루트 노드부터 특정 노드까지 최단 거리로 갔을 때의 거리
    - 높이 : 루트 노드부터 리프 노드까지 거리 중 가장 긴 거리
    - 레벨 : 보통은 깊이와 같은 의미
    - 서브트리 : 트리 내의 하위집합
- 이진 트리 : 각 자식의 노드 수가 두 개 이하인 트리
    - 정이진 트리(Full binary tree) : 각 노드들의 자식 노드가 0 또는 2개인 이진 트리
    - 완전 이진 트리(Complete binary tree) : 왼쪽에서부터 채워져 있는 이진 트리/ 마지막 레벨을 제외하고는 모두 채워져있음.
    - 변질 이진 트리(Degenerate binary tree) : 각 노드들의 자식 노드가 하나밖에 없는 이진 트리
    - 포화 이진 트리(Perfect binary tree) : 모든 노드가 꽉 차 있는 이진 트리
    - 균형 이진 트리(Balanced binary tree) : 왼쪽과 오른쪽 노드의 높이 차이가 1 이하인 이진 트리
- 이진 탐색 트리(BST, Binary Search Tree)
    - 노드의 오른쪽 하위 트리에는 ‘노드 값 보다 큰 값'만 포함되고, 왼쪽 하위 트리에는 ‘노드 값 보다 작은 값'만 들어 있는 트리
    - 탐색 시 평균 O(longn), 최악의 경우(선형적일 경우) O(n)이 소요됨
- AVL 트리(Adelson-Velsky and Landis Tree)
    - 최악의 경우 선형적인 트리가 되는 것을 방지하고 스스로 균형을 잡는 이진 탐색 트리
    - 두 자식 서브트리의 높이는 항상 최대 1만큼 차이남
    - 삽입, 삭제를 할 때마다 균형을 맞추기 위해 트리 일부를 왼쪽 혹은 오른쪽으로 회전 시킴
    - 삽입, 삭제, 탐색 시 O(logn)의 시간복잡도를 가짐
- 레드 블랙 트리
    - 균형 이진 탐색 트리의 형태
    - 각 노드는 빨간색 또는 검은색의 색상을 나타내는 추가 비트를 저장하며, 삽입 및 삭제 중에 트리가 균형을 유지하도록 사용됨
    - ‘모든 리프 노드와 루트 노드는 블랙이고 어떤 노드가 레드이면 그 노드의 자식은 반드시 블랙이다’ 등의 규칙
    - 삽입, 삭제, 탐색 시 O(logn)의 시간복잡도를 가짐

---

### 3. 힙(Heap)

완전 이진 트리 기반의 자료 구조. 최대힙과 최소힙 두 가지가 있고 해당 힙에 따라 특정한 특징을 지킨 트리

- 최대힙(최소힙)
    - 루트 노드에 있는 키는 모든 자식에 있는 키 중에 가장 커야(작아야) 함
    - 각 노드와 자식 노드와의 관계도 이와 같은 특징이 재귀적으로 이루어짐
- 최대힙(최소힙)의 삽입
    - 힙의 마지막 노드에 이어서 삽입
    - 새로운 노드를 부모 노드들과의 크기를 비교하며 교환해서 힙의 성질을 만족시킴
- 최대힙(최소힙)의 삭제
    - 최댓값(최솟값)은 루트 노드이므로 루트 노드가 삭제되고, 마지막 노드와 루트 노드를 스왑하여 삽입과 같은 과정을 거침

---

### 4. 우선순위 큐(**Priority Queue)**

우선순위 대기열이라고도 함. 대기열에서 우선순위가 높은 요소가 우선순위가 낮은 요소보다 먼저 제공되는 자료 구조.

- 우선순위 큐는 힙을 기반으로 구현 됨.

---

### 5. 맵(Map)

특정 순서에 따라 키와 매핑된 값의 조합으로 형성된 자료 구조. (Python의 dictionary 자료형을 생각하면 쉽다)

- 레드 블랙 트리 자료 구조를 기반으로 형성. 삽입되면 자동으로 정렬
- map은 해시 테이블을 구현할 때 사용
- 정렬을 보장하는 map과 정렬을 보장하지 않는 unordered_map 두 가지가 있음

---

### 6. 셋(Set)

특정 순서에 따라 고유한 요소를 저장하는 컨테이너. 중복되는 요소는 없고 오직 희소한(unique) 값만 저장하는 자료구조.

---

### 7. 해시 테이블(Hash Table)

무한에 가까운 데이터들을 유한한 개수의 해시 값으로 매핑한 테이블

- 삽입, 삭제, 탐색 시 평균 O(1)의 시간복잡도를 가짐
- unordered_map으로 구현함

## Quiz

[0811_CS_Quiz](https://www.notion.so/0811_CS_Quiz-1ecbbb06b42645c7aec9b936fe929e83)